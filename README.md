## Sol Commons on-chain toolkit

Sol Commons ports the analytical Commons Stack toolkit ([commonsstack.org](https://commonsstack.org)) into Solana. At its heart are

1. **Augmented Bonding Curve (ABC)** – a smart-market maker whose pricing curve sends every contribution into a Reserve Pool for liquidity and a Funding Pool that is immediately spendable by the commons. Buyers mint tokens along the curve, contributors join hatches via allowlists, and every exit returns an exit tribute to the funding pool so the system is self-sustaining.
2. **Conviction Voting** – a continuous governance flow where people lock Commons tokens behind proposals and conviction accumulates proportional to time held; the commons only spends treasury funds once accumulated conviction crosses an adaptive threshold, aligning incentives between contributors and fund recipients.
3. **Commons Assembly/Connected services** – off-chain tools (Praise/Tokenlog/Simulator) surface community recognition, GitHub issue prioritization, and parameter kits that feed into the on-chain ABC + Conviction Voting loop to fund real-world public goods via the commons treasury.

### What this repo provides

| Layer | Description |
|---|---|
| `commons_hatch`, `commons_abc` | Anchor programs that open a Merkle-gated hatch, settle contributions in a vault, and initialize the ABC curve via CPI. The curve tracks a 3-account setup (curve_config PDA, reserve vault, treasury), handles friction splits, and supports refund/claim flows (see existing tests for minted, refunded, and claimed scenarios). |
| `commons_conviction_voting` | Converts the classic CV pattern into Anchor: stakes flow through a global staking vault/PDA, every stake/unstake updates conviction with decay, a helper computes the required conviction threshold, and execution is blocked until the treasury-target ratio is satisfied. Tests cover math correctness and the lifecycle. |
| `commons_rewards` | Merkle-based reward epochs with claim replay protection—every epoch stores its vault + PDA bumps, enforces Merkle proofs, and now records claimed leaves so duplicates fail with `AlreadyClaimed`. |
| Off-chain services | Praise, Tokenlog, and Simulator scaffolds provide deterministic data: Praise emits Merkle roots + proofs, Tokenlog fetches GitHub issues before failing back to mocks, and the Simulator provides curve scenarios + metrics so the Mocha/Anchor suites recreate the same parameters used in deployment. |
| Integration tests | `tests/offchain-integration.js` validates the off-chain pipeline; `scripts/run-offchain-with-validator.sh` runs those Mocha tests against `solana-test-validator`; `tests/sol-commons-workspace.ts` shows how the Merkle batch funds a `commons_rewards` epoch, while `tests/commons_conviction_voting/conviction.rs` now ensures Treasury transfers only happen via the CV PDA under the right thresholds. |

### Example scenarios

1. **Community Hatch + ABC deployment** – The community runs `commons_hatch.initialize` with parameters, an allowlisted Merkle root, and a reserve mint. Contributors deposit during the open window; the finalizer uses `commons_abc.initialize_curve` to mint treasury and reserve vaults, then contributors can claim tokens post-hatch.
2. **Continuous funding via conviction** – Commons token holders stake into proposals via `commons_conviction_voting.stake_tokens`. `update_conviction_for_proposal` keeps a decayed conviction value, and only when the calculated threshold is met does `check_and_execute` approve the request and pay out from the treasury via the CV PDA authority.
3. **Praise → reward epoch** – The off-chain Praise service collects kudos, builds a Merkle batch, and `tests/sol-commons-workspace.ts` demonstrates how that batch becomes a `commons_rewards` epoch tied to a PDA vault with a deterministic mint. Claimers can later pull funds from the vault using the proof generated by the same off-chain service.

### How to get started

1. Install Anchor and run `yarn` in `sol-commons-workspace`; the workspace already includes `@coral-xyz/anchor`, `@solana/spl-token`, and the off-chain scaffolds plus the generated `commons_rewards` IDL under `offchain/commons_rewards.idl.json`.
2. Start a local validator (`solana-test-validator`) before running Anchor tests so the new off-chain inputs can be validated, then run `yarn test:offchain` and `yarn test:offchain-validator` (the script rewrites `ANCHOR_PROVIDER_URL` and runs the Mocha suite under the validator) to exercise both the off-chain Merkle flow and the guarded conviction/treasury paths plus `cargo test -p commons_hatch`/`commons_abc`/`commons_conviction_voting`/`commons_rewards`.
3. Use `Anchor.toml` + `cargo test` to deploy locally. Point `offchain/*/config.json` to the deployed programs and replay the on-chain flows via the integration tests once `solana-test-validator` is running.

### Staying aligned

- `sol-commons-v17`: hatch gating is in place, but consider adding more integration tests to prove contributions obey slot windows and finalization states.
- `sol-commons-2bh`: the scaffolds & integration tests exist, so this issue now becomes implementing real services (e.g., praise aggregator, GitHub tokenlog bot, cadCAD simulator) that exercise the Anchor tests end-to-end.

### Tests

```bash
yarn test:offchain
cargo test -p commons_hatch
cargo test -p commons_abc
cargo test -p commons_conviction_voting
cargo test -p commons_rewards
cd sol-commons-workspace && yarn test:offchain-validator
```
